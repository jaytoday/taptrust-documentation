---
title: "File Upload Encryption"
description: "How TapTrust encrypts file attachments while maintaining AI assistant compatibility"
---

## Overview

TapTrust implements optional client-side file encryption to ensure that file attachments can be encrypted before being stored in the cloud, while still allowing AI assistants to process the file contents during conversations.

<Note>
  File encryption is controlled by the `NEXT_PUBLIC_ENCRYPT_FILE_UPLOADS` environment variable. When set to `true`, files are encrypted client-side before upload. When `false` or unset, files are uploaded without encryption for faster processing.
</Note>

## How File Encryption Works

## Configuration

### Environment Variable Setup

Add to your `.env` file:

```bash
# Enable file encryption (recommended for production)
NEXT_PUBLIC_ENCRYPT_FILE_UPLOADS=true

# Disable file encryption (faster, development mode)
NEXT_PUBLIC_ENCRYPT_FILE_UPLOADS=false
```

### Behavior Modes

**When Encryption is Disabled (`false` or unset):**
- Files uploaded directly to blob storage without encryption
- Faster upload and processing
- Standard security (blob storage level)
- No decryption needed for AI processing

**When Encryption is Enabled (`true`):**
- Files encrypted client-side before upload
- AES-256-GCM encryption with random keys
- Zero-knowledge storage (encrypted data only)
- Automatic decryption for AI processing

### 1. Client-Side Encryption Process

When encryption is enabled and a user uploads a file in TapTrust:

1. **File Selection**: User selects a file (e.g., `document.pdf`, `image.png`)
2. **Key Generation**: A unique 256-bit AES encryption key is generated for this specific file
3. **Encryption**: File content is encrypted using AES-256-GCM with a random IV
4. **UUID Generation**: A random UUID filename is generated to prevent exposing the original filename
5. **Upload**: Encrypted file is uploaded to storage with UUID + extension + `.enc` (e.g., `abc123-def456.png.enc`)
6. **Metadata Storage**: Original filename and content type are preserved in the attachment metadata

```typescript
// Example attachment metadata for an encrypted PNG file
const attachment = {
  name: "screenshot.png",           // Original filename for display
  url: "https://blob.../abc123-def456.png.enc", // Encrypted file URL with UUID
  contentType: "image/png",         // Original content type for AI
  isEncrypted: true,               // Encryption flag
  encryptionKey: "base64key...",   // Encryption key for decryption
  originalSize: 245760             // Original file size
}
```

### 2. AI Assistant Content Type Detection

The AI assistant knows the original content type through multiple mechanisms:

#### Method 1: Attachment Metadata (Primary)
The attachment object preserves the original `contentType` field:
```typescript
// When sending to AI, the original content type is maintained
{
  type: 'file',
  url: temporaryDecryptedUrl,
  name: 'screenshot.png',
  mediaType: 'image/png'  // ‚Üê AI knows this is a PNG image
}
```

#### Method 2: Filename Extension (Fallback)
The server can extract content type from the UUID filename's extension:
```typescript
// abc123-def456.pdf.enc ‚Üí application/pdf
// xyz789-abc123.png.enc ‚Üí image/png  
// uuid12-uuid34.docx.enc ‚Üí application/vnd.openxmlformats-officedocument.wordprocessingml.document
```

#### Method 3: File Header Analysis (Future Enhancement)
After decryption, the first few bytes can be analyzed to detect file type:
```typescript
// PNG files start with: 89 50 4E 47 0D 0A 1A 0A
// PDF files start with: 25 50 44 46 (ASCII: %PDF)
// JPEG files start with: FF D8 FF
```

## AI Processing Flow

### Step-by-Step Process

1. **Message Creation**: User creates message with encrypted file attachment
2. **Pre-Processing**: Before sending to AI, TapTrust processes encrypted attachments:
   ```typescript
   async function processEncryptedAttachments(message) {
     for (const attachment of message.attachments) {
       if (attachment.isEncrypted) {
         // Download encrypted file
         const encryptedData = await fetch(attachment.url)
         
         // Decrypt using stored key
         const decryptedData = await decrypt(encryptedData, attachment.encryptionKey)
         
         // Create temporary blob URL with original content type
         const tempUrl = createTemporaryBlobUrl(decryptedData, attachment.contentType)
         
         // Update attachment for AI processing
         attachment.url = tempUrl
         attachment.isEncrypted = false
       }
     }
   }
   ```

3. **AI Processing**: AI receives decrypted file with correct content type
4. **Cleanup**: Temporary URLs are automatically revoked after processing

### Content Type Preservation

```typescript
// Original file upload
File: screenshot.png (image/png, 245KB)

// After encryption  
Stored: screenshot.png.enc (application/octet-stream, 246KB)
Metadata: { contentType: "image/png", originalSize: 245760 }

// For AI processing
Temporary: blob:https://app.taptrust.com/abc123 (image/png, 245KB)
Message: { type: "file", mediaType: "image/png", url: "blob:..." }
```

## Security Features

### Encryption Specifications
- **Algorithm**: AES-256-GCM (Galois/Counter Mode)
- **Key Size**: 256 bits (32 bytes)
- **IV Size**: 96 bits (12 bytes) - randomly generated per file
- **Authentication**: Built-in authentication tag prevents tampering

### Key Management
- **Generation**: Cryptographically secure random keys per file
- **Storage**: Keys stored client-side only, never on server
- **Transmission**: Keys only sent to AI during active processing
- **Cleanup**: Keys removed from memory after processing

### Privacy Guarantees
- ‚úÖ **Zero-Knowledge Storage**: Only encrypted data stored in cloud
- ‚úÖ **Ephemeral Decryption**: Files only decrypted during AI processing
- ‚úÖ **Key Isolation**: File keys separate from user's main encryption key
- ‚úÖ **Temporary Access**: AI gets temporary access via blob URLs
- ‚úÖ **Automatic Cleanup**: No persistent decrypted copies

## File Type Support

### Supported File Types for Encryption

All standard TapTrust file types can be encrypted:

**Images**
- PNG, JPEG, GIF, WebP
- Content type preserved for AI image processing

**Documents**  
- PDF, Word (.doc, .docx), PowerPoint (.ppt, .pptx)
- Content type enables AI document analysis

**Spreadsheets**
- Excel (.xls, .xlsx), CSV
- Content type allows AI data processing

**Code Files**
- JavaScript, TypeScript, JSON, HTML, CSS, XML
- Content type enables syntax-aware AI assistance

**Text Files**
- Plain text, Markdown
- Content type preserves formatting context

## Browser Compatibility

### Web Crypto API Requirements
- **Chrome**: Version 37+ (2014)
- **Firefox**: Version 34+ (2014)  
- **Safari**: Version 7+ (2013)
- **Edge**: All versions

### Fallback Behavior
If Web Crypto API is unavailable:
- Graceful degradation to unencrypted upload
- User notification about reduced privacy
- Full functionality maintained

## Implementation Details

### Client-Side Encryption
```typescript
// File encryption process
export async function encryptFileContent(
  fileBuffer: ArrayBuffer,
  key: Uint8Array
): Promise<ArrayBuffer> {
  const iv = crypto.getRandomValues(new Uint8Array(12))
  const cryptoKey = await crypto.subtle.importKey('raw', key, 'AES-GCM', false, ['encrypt'])
  const encryptedData = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, cryptoKey, fileBuffer)
  
  // Prepend IV to encrypted data
  const result = new Uint8Array(12 + encryptedData.byteLength)
  result.set(iv, 0)
  result.set(new Uint8Array(encryptedData), 12)
  return result.buffer
}
```

### AI Processing Integration
```typescript
// AI message processing with encrypted files
const processedMessage = await processEncryptedAttachments(userMessage)
const aiResponse = await streamText({
  model: aiModel,
  messages: convertToModelMessages([...messages, processedMessage]),
  // AI receives files with correct content types
})
```

## Performance Considerations

### Encryption Impact
- **Small Files (<1MB)**: ~50-100ms encryption time
- **Large Files (10MB)**: ~500ms-1s encryption time  
- **Memory Usage**: 2x file size during encryption (original + encrypted)

### AI Processing Impact
- **Decryption**: ~50-200ms per file
- **Temporary URLs**: Minimal memory footprint
- **Network**: No additional bandwidth (files already downloaded)

### Optimizations
- **Streaming**: Large files processed in chunks to reduce memory usage
- **Web Workers**: Encryption moved to background threads (planned)
- **Caching**: Decrypted content cached for conversation duration (planned)

## Troubleshooting

### Common Issues

**"File type not supported" Error**
- Ensure file has supported extension before encryption
- Check that `application/octet-stream` is in `SUPPORTED_FILE_TYPES`

**AI Cannot Process File**  
- Verify `contentType` field is preserved in attachment metadata
- Check that temporary blob URL was created successfully
- Confirm decryption completed without errors

**Large File Upload Fails**
- Check file size limits based on original content type
- Verify browser memory can handle 2x file size during encryption

### Debug Information

Enable debug logging to trace the encryption flow:
```typescript
// Console logs show encryption progress
üîê Starting encrypted file upload: { name: "file.pdf", size: 245760 }
‚úÖ File encrypted successfully: { originalSize: 245760, encryptedSize: 245792 }
üîì Processing encrypted file for AI: { name: "file.pdf", mediaType: "application/pdf" }
‚úÖ File decrypted and made available to AI: { decryptedSize: 245760 }
üßπ Cleaned up temporary blob URL for: file.pdf
```

## Future Enhancements

### Planned Features
- **File Expiration**: Automatic cleanup of old encrypted files
- **Key Rotation**: Periodic re-encryption with new keys
- **Chunked Processing**: Stream large files for better performance
- **Advanced Auditing**: Detailed logging of file access patterns
- **Client-Side Compression**: Reduce file sizes before encryption

### Security Improvements
- **Hardware Security**: Use hardware security modules when available
- **Key Derivation**: Derive file keys from master key for easier management
- **Zero-Knowledge Proofs**: Verify file integrity without decryption
- **Secure Deletion**: Ensure temporary files are properly wiped

---

This encryption system ensures that TapTrust maintains its zero-knowledge architecture while providing seamless AI assistant functionality with file attachments.